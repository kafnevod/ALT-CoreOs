# Anatomy of an OSTree repository

    Core object types and data model
        Commit objects
        Dirtree objects
        Dirmeta objects
        Content objects
    Repository types and locations
        Refs
        The summary file
            Licensing for this document:
## Основные типы объектов и модель данных

Основные идеи и модели OSTree позаимствованы из git;.
Стоит потратить некоторое время на то, чтобы ознакомиться с [Git Internals](http://git-scm.com/book/en/v2), так как этот раздел предполагает некоторые знания о том, как работает git.

Типы объектов OSTree похожи на git; у него есть объекты фиксации (commit) и объекты содержимого (content). 
В Git есть объекты-каталогов, тогда как OSTree разбивает их на «dirtree» и «dirnmeta». 
В  отличие от git, контрольные суммы OSTree - это SHA256. 
И что наиболее важно, его объекты содержимого включают атрибуты uid, gid и extended (но без timestamps). 


### Объекты коммит

Коммит-объект  содержит метаданные, такие как временная метка, сообщение журнала и, что наиболее важно, ссылку на  dirtree/dirmeta c контрольными суммами, которые описывают корневой каталог файловой системы. 
Также, как и в git, у каждого коммита в OSTree может быть родитель. 
Он предназначен для хранения истории ваших двоичных сборок, точно так же, как git хранит историю управления версиями. 
Однако OSTree также упрощает удаление данных при условии, что вы можете восстановить их из исходного кода. 

### Объекты Dirtree

dirtree содержит отсортированный массив пар (имя файла, контрольная сумма) для контент-объектов  и второй отсортированный массив (имя файла, контрольная сумма dirtree, контрольная сумма dirmeta), которые являются подкаталогами. Этот тип объектов хранится в виде файлов с расширением `*.dirtree` в каталоге объектов. 

### Объекты Dirmeta
В git древовидные объекты содержат метаданные, такие как права доступа для своих потомков. 
Но OSTree разбивает это на отдельный объект, чтобы избежать дублирования расширенных списков атрибутов. 
Эти типы объектов хранятся в виде файлов с суффиксом `*.dirmeta` в каталоге объектов. 

### Объекты контента

В отличие от первых трех типов объектов, которые представляют собой метаданные, предназначенные для использования с помощью `mmap()`, объект содержимого имеет отдельные разделы внутреннего заголовка и полезной нагрузки. Заголовок содержит uid, gid, mode и цель символической ссылки (для символических ссылок), а также расширенные атрибуты. После заголовка для обычных файлов следует содержимое. Эти части вместе образуют хэш SHA256 для объектов содержимого. Объекты типа контента в этом формате существуют только в архивных репозиториях OSTree. Сегодня часть содержимого заархивирована с помощью gzip, а объекты хранятся в виде файлов, оканчивающихся на .filez, в каталоге объектов. Поскольку хэш SHA256 формируется на несжатом содержимом, эти файлы не соответствуют хэшу, которым они названы.

Формат данных OSTree намеренно не содержит отметок времени (timestamps). Причина в том, что файлы данных могут быть загружены в разное время и разными системами сборки, поэтому они будут иметь разные временные метки, но идентичное физическое содержимое. Эти файлы могут быть большими, поэтому большинство пользователей хотели бы, чтобы они были общими как в репозитории, так и между репозиторием и развертываниями.

Это может вызвать проблемы с программами, которые проверяют, не устарели ли файлы, сравнивая временные метки. Для Git логичный выбор - не связываться с временными метками, потому что ненужное перестроение лучше, чем сломанное дерево. Однако OSTree привязывают файлы через жестские ссылки (hardlinks), чтобы проверить их, и предполагается, что коммиты внутренне согласованы и не требуют этапов сборки. 
По этой причине OSTree действует так, как будто для всех временных меток установлено значение time_t 0, поэтому сравнения будут считаться актуальными. 
Обратите внимание, что в некоторых выпусках OSTree использовал 1 для исправления предупреждений, таких как GNU Tar, выдающий «неправдоподобно старую отметку времени» с 0; однако, пока у нас не будет механизма для точного перехода к 1, для совместимости OSTree снова будет использовать ноль.

## Типы и расположение репозиториев

Также, в отличие от git, репозиторий OSTree может находиться в одном из четырех отдельных режимов: bare, bare-user, bare-user-only и archive. 

bare репозиторий - это репозиторий, в котором файлы содержимого хранятся как обычные файлы; он разработан как источник «фермы жестких ссылок», где каждая ветка операционной системы просто связана с ней. 
Если вы хотите хранить файлы, принадлежащие, например, root в этом режиме, вы должны запустить OSTree с правами root.

Режим `bare-user` - это более позднее дополнение, похожее на `bare`, но его можно создавать как без полномочий root. 
В этом режиме расширенные метаданные, такие как идентификатор владельца, gid и расширенные атрибуты, хранятся в расширенных атрибутах под именем `user.ostreemeta`, но фактически не применяются. Режим `bare-user` полезен для систем сборки, которые работают из под пользователя с не-root привелегями, но хотят генерировать контент, принадлежащий суперпользователю, а также для 
не-root контейнерных систем.

Режим `bare-user-only mode` - это вариант режима для простого пользователя. В отличие от простого пользователя, ни владелец, ни расширенные атрибуты не сохраняются. 
Эти репозитории предназначены для извлечения в пользовательском режиме (с флагом -U), где эта информация в любом случае не применяется. 
Следовательно, в этом режиме можно "потерять" метаданные. 
Основным преимуществом режима `bare-user-only mode` является то, что репозитории могут храниться в файловых системах, которые не поддерживают расширенные атрибуты, такие как tmpfs.

Режим `archive` предназначен для обслуживания через простой HTTP. 
Как и файлы tar, он может быть прочитан/записан пользователями без полномочий root.

В системе, развернутой как OSTree, «системным репозиторием» является `/ostree/repo`. 
Он может быть прочитан любым uid, но записан только пользователем root. 
Команда ostree по умолчанию работает с системным репозиторием; вы можете указать аргумент --repo, чтобы переопределить это, или установить переменную среды $OSTREE_REPO. 

### Ссылки (Refs)

Как и git, OSTree использует терминологию «ссылки» (сокращенно «refs»), которые представляют собой текстовые файлы с именами (ссылками) на определенные коммиты. 
См. Документацию Git для получения информации о том, как git их использует. Однако, в отличие от git, обычно не имеет смысла иметь «главную» master-ветку. 
В OSTree существует соглашение для ссылок, которое выглядит следующим образом: `exampleos/buildmaster/x86_64-runtime` и `exampleos/buildmaster/x86_64-devel-debug`. 
Эти две ссылки указывают на два разных сгенерированных дерева файловых систем. В этом примере дерево «среды выполнения» runtime содержит ровно столько, чтобы запустить базовую систему, 
а «devel-debug» содержит все инструменты разработчика и информацию об отладке.

Ostree поддерживает простой синтаксис с использованием символа ^ для ссылки на родительский элемент данного коммита. 
Например, `exampleos/buildmaster/x86_64-runtime^` относится к предыдущей сборке, а `exampleos/buildmaster/x86_64-runtime^^` относится к предыдущей. 

### The summary file

A later addition to OSTree is the concept of a “summary” file, created via the ostree summary -u command. This was introduced for a few reasons. A primary use case is to be compatible with Metalink, which requires a single file with a known checksum as a target.

The summary file primarily contains two mappings:

-    A mapping of the refs and their checksums, equivalent to fetching the ref file individually
-    A list of all static deltas, along with their metadata checksums

This currently means that it grows linearly with both items. On the other hand, using the summary file, a client can enumerate branches.

Further, fetching the summary file over e.g. pinned TLS creates a strong end-to-end verification of the commit or static delta.

The summary file can also be GPG signed (detached). This is currently the only way to provide GPG signatures (transitively) on deltas.

If a repository administrator creates a summary file, they must thereafter run ostree summary -u to update it whenever a ref is updated or a static delta is generated.
