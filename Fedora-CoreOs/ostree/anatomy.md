# Анатомия репозитория OSTree 

- Основные типы объектов и модель данных
  *  Объекты коммит (Commit objects)
  *  Объекты Dirtree
  *  Объекты Dirmeta
  *  Объекты контента (Content objects)
- Типы и расположение репозиториев
- Ссылки (Refs)
- Сводный (summary) файл
      
## Основные типы объектов и модель данных

Основные идеи и модели `OSTree` позаимствованы из `git`;.
Стоит потратить некоторое время на то, чтобы ознакомиться с [Git Internals](http://git-scm.com/book/en/v2), так как этот раздел предполагает некоторые знания о том, как работает `git`.

Типы объектов `OSTree` похожи на `git`.
У него есть `коммиты` (`commit`) и `объекты содержимого` (`content`). 
В `git` есть объекты-каталогов, тогда как OSTree разбивает их на «`dirtree`» и «`dirnmeta`». 
В  отличие от `git`, `контрольные суммы` (`checksums`) `OSTree` имеют тип  `SHA256`. 
И что наиболее важно, его объекты содержимого включают атрибуты `uid`, `gid` и `extended` (**но без `timestamps`**). 


### Объекты коммит (Commit objects)

`Коммит-объект`  содержит `метаданные`, такие как `временная метка`, `сообщение журнала` и, что наиболее важно, ссылку на  `dirtree`/`dirmeta` c `контрольными суммами`, которые описывают корневой каталог файловой системы. 
Также, как и в `git`, у каждого `коммита` в `OSTree` может быть `родитель`. 
Он предназначен для хранения истории ваших двоичных сборок, точно так же, как `git` хранит историю управления версиями. 
Однако `OSTree` также упрощает удаление данных при условии, что вы можете восстановить их из исходного кода. 

### Объекты Dirtree

`dirtree` содержит отсортированный `массив пар` (`имя файла`, `контрольная сумма`) для `контент-объектов ` 
и `второй отсортированный массив` (`имя файла`, `контрольная сумма dirtree`, `контрольная сумма dirmeta`) для подкаталогов. 
Этот тип объектов хранится в виде файлов с расширением `*.dirtree` в каталоге объектов. 

### Объекты Dirmeta
В `git` древовидные объекты содержат метаданные, такие как права доступа для своих потомков. 
Но `OSTree` разбивает это на отдельный объект, чтобы избежать дублирования расширенных списков атрибутов. 
Эти типы объектов хранятся в виде файлов с суффиксом `*.dirmeta` в каталоге объектов. 

### Объекты контента (Content objects)

В отличие от первых трех типов объектов, которые представляют собой метаданные, предназначенные для использования с помощью `mmap()`, `объект контента` имеет отдельные разделы внутреннего заголовка и содержимого . 
Заголовок содержит `uid`, `gid`, `mode` и `цель символической ссылки` (для символических ссылок), а также `расширенные атрибуты`. 
После заголовка для обычных файлов следует содержимое. Эти части вместе образуют `хэш SHA256` для объектов содержимого. 
Объекты типа контента в этом формате существуют только в архивных репозиториях OSTree. 
В настоящее время часть содержимого заархивирована с помощью `gzip,` а объекты хранятся в виде файлов, оканчивающихся на `.filez`, в каталоге объектов. 
Поскольку `хэш SHA256` формируется на `несжатом содержимом`, эти файлы `не соответствуют хэшу`, которым они названы.

Формат данных `OSTree` **намеренно не содержит отметок времени (timestamps)**. 
Причина  заключается в том, что файлы данных могут быть загружены в разное время и разными системами сборки, поэтому они будут иметь разные временные метки, но идентичное физическое содержимое. 
Эти файлы могут быть большими, поэтому большинство пользователей хотели бы, чтобы они были общими как в репозитории, так и между репозиторием и развертываниями.

Это может вызвать проблемы с программами, которые проверяют, не устарели ли файлы, сравнивая временные метки. 
Для `git` логичный выбор - не связываться с временными метками, потому что ненужное перестроение лучше, чем сломанное дерево. 
Однако `OSTree` привязывают файлы через `жестские ссылки` (`hardlinks)`, чтобы проверить их, и предполагается, что `коммиты внутренне согласованы` и не требуют этапов сборки. 
По этой причине `OSTree` действует так, как будто для всех временных меток установлено значение `time_t` `0`, поэтому сравнения будут считаться актуальными. 
Обратите внимание, что в некоторых выпусках `OSTree` для временных меток использовано значение 1 для исправления предупреждений, таких как `GNU Tar`, выдающий предупреждение типа *«неправдоподобно старая отметка времени» с 0*.
Jднако, пока у нас не будет механизма для точного перехода к значению `1`, для совместимости `OSTree` снова будет использовать `0`.

## Типы и расположение репозиториев

Также, в отличие от `git`, репозиторий `OSTree` может находиться в одном из четырех отдельных режимов: 
- `bare, 
- bare-user, 
- bare-user-only
- archive. 

`bare` репозиторий - это репозиторий, в котором файлы содержимого хранятся как обычные файлы. 
Он разработан как источник «`фермы жестких ссылок`», где каждая `ветка операционной системы` просто связана с ней. 
Если вы хотите хранить файлы, принадлежащие, например, `root` в этом режиме, вы должны запустить `OSTree` с правами `root`.

Режим `bare-user` - это более позднее дополнение, похожее на `bare`, но его можно создавать как без полномочий `root`. 
В этом режиме `расширенные метаданные`, такие как `uid`, `gid` и `расширенные атрибуты`, хранятся в расширенных атрибутах под именем `user.ostreemeta`, но фактически не применяются. 
Режим `bare-user` полезен для систем сборки, которые работают из под пользователя с `не-root` привелегями, но хотят генерировать контент, принадлежащий суперпользователю, а также для `не-root контейнерных систем`.

Режим `bare-user-only` - это вариант режима `bare-user`. 
В отличие от простого пользователя, ни владелец, ни расширенные атрибуты не сохраняются. 
Эти репозитории предназначены для извлечения в пользовательском режиме (с флагом `-U`), где эта информация в любом случае не применяется. 
Следовательно, в этом режиме можно "потерять" метаданные. 
Основным преимуществом режима `bare-user-only` является то, что репозитории могут храниться в файловых системах, которые не поддерживают расширенные атрибуты, такие как `tmpfs`.

Режим `archive` предназначен для обслуживания через простой `HTTP`. 
Как и файлы `tar`, он может быть прочитан/записан пользователями без полномочий `root`.

В системе, развернутой как `OSTree,` «системным репозиторием» является `/ostree/repo`. 
Он может быть прочитан любым `uid,` но записан только пользователем `root`. 
Команда `ostree` по умолчанию работает с системным репозиторием; вы можете указать аргумент -`-repo`, чтобы переопределить это, или установить переменную среды `$OSTREE_REPO`. 

## Ссылки (Refs)

Как и `git`, `OSTree` использует терминологию «`ссылки`» («`refs`»), которые представляют собой текстовые файлы с именами (ссылками) на определенные `коммиты`. 
См. [документацию Git](https://git-scm.com/book/en/v2/Git-Internals-Git-References) для получения информации о том, как `git` их использует. 
Однако, в отличие от `git`, обычно не имеет смысла иметь *«главную» `master`-ветку*. 
В `OSTree` существует соглашение для ссылок, которое выглядит следующим образом: `exampleos/buildmaster/x86_64-runtime` и `exampleos/buildmaster/x86_64-devel-debug`. 
Эти две ссылки указывают на два разных сгенерированных дерева файловых систем. В этом примере дерево «среды выполнения» `runtime` содержит ровно столько, чтобы запустить базовую систему, 
а «`devel-debug`» содержит все инструменты разработчика и информацию об отладке.

Ostree поддерживает простой синтаксис с использованием символа `^` для ссылки на родительский элемент данного коммита. 
Например, `exampleos/buildmaster/x86_64-runtime^` относится к предыдущей сборке, а `exampleos/buildmaster/x86_64-runtime^^` относится к предыдущей. 

## Сводный (summary) файл

Более поздним дополнением к `OSTree` является концепция «`сводного`» (`summary`) файла, созданного с помощью команды `ostree summary -u`. 
Это было введено по нескольким причинам. 
Основной вариант использования - совместимость с `Metalink`, для которого в качестве цели требуется один файл с известной контрольной суммой.

Сводный файл в основном содержит два сопоставления:

- Привязка ссылок (`refs`) и их контрольных сумм, что эквивалентно получению `ref-файла` индивидуально
- Список всех `статических дельт` с контрольными суммами их метаданных

В настоящее время это означает, что он растет линейно с обоими элементами. 
С другой стороны, используя сводный `summary-файл`, клиент может "пронумеровать" ветки.

Кроме того, загрузка сводного `summary-файла`, например, с прикрепленным `TLS` создает надежную `end-to-end` проверку `коммитов` или `статической дельты`.

Сводный `summary-файл` также может быть подписан `GPG` (`detached`). 
В настоящее время это единственный способ поддержать подписи `GPG` (транзитивно) для `дельт`.

Если администратор репозитория создает `summary-файл,` он должен затем запустить `ostree summary -u`, чтобы обновлять его всякий раз, когда обновляется ссылка или создается `статическая дельта`. 
