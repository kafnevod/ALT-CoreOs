# Адаптация существующих основных дистрибутивов 

- Схема файловой системы
- Загрузка и технология initramfs
- /usr/lib/passwd
- Адаптация существующих менеджеров пакетов

## Схема файловой системы

Прежде всего, `OSTree` стимулирует системы внедрять `UsrMove`. 
Данный подход предлагается для того, чтобы избежать необходимости в дополнительных `bind mounts`. 
По умолчанию `dracut hook` в OSTree создает `bind mounts` в режиме только для чтения только для каталога `/usr`; 
**вы, конечно, можете создать отдельные `bind-mounts` для `/bin`, всех вариантов `/lib` и т. д.** 
Так что это не является жестким требованием.

Помните, поскольку по умолчанию система загружается в `chroot-эквиваленте`, должен быть какой-то способ обратиться к реальной физической корневой файловой системе. 
Следовательно, дерево вашей операционной системы должно содержать пустой каталог `/sysroot`; 
во время загрузки `OSTree` сделает через `bind-mount` этот каталог привязанным к физическому `/` `корневому каталогу`. 
Есть прецедент использования этого имени в контексте `initramfs`?. 

Кроме того, вы должны создать символическую ссылку `/ostree` верхнего уровня, которая указывает на `/sysroot/ostree`, чтобы инструмент `OSTree` во время выполнения мог постоянно находить системные данные независимо от того, работает ли он в физическом корне или внутри развертывания.

Поскольку `OSTree` при обновлении сохраняет только `/var`  (`chroot-каталог` каждого развертывания в конечном итоге будет собираться мусором), вам нужно будет выбрать, как поддерживать другие доступные для записи каталоги верхнего уровня, указанные в [Стандарте иерархии файловой системы](https://www.pathname.com/fhs/). 
Ваша операционная система, конечно, может не поддерживать некоторые из них, такие как `/usr/local`, но рекомендуется следующий набор: 

    /home → /var/home
    /opt → /var/opt
    /srv → /var/srv
    /root → /var/roothome
    /usr/local → /var/usrlocal
    /mnt → /var/mnt
    /tmp → /sysroot/tmp

Более того, поскольку `/var` по умолчанию пуст, ваша операционная система должна будет динамически создавать их целевые объекты при загрузке. 
Хороший способ сделать это - использовать `systemd-tmpfiles`, если ваша ОС использует `systemd`. Например: 
- d /var/log/journal 0755 root root -
- L /var/home - - - - ../sysroot/home
- d /var/opt 0755 root root -
- d /var/srv 0755 root root -
- d /var/roothome 0700 root root -
- d /var/usrlocal 0755 root root -
- d /var/usrlocal/bin 0755 root root -
- d /var/usrlocal/etc 0755 root root -
- d /var/usrlocal/games 0755 root root -
- d /var/usrlocal/include 0755 root root -
- d /var/usrlocal/lib 0755 root root -
- d /var/usrlocal/man 0755 root root -
- d /var/usrlocal/sbin 0755 root root -
- d /var/usrlocal/share 0755 root root -
- d /var/usrlocal/src 0755 root root -
- d /var/mnt 0755 root root -
- d /run/media 0755 root root -

Особо обратите внимание на двойную переадресацию на `/home`. 
По умолчанию каждое развертывание будет совместно использовать глобальный каталог верхнего уровня `/home` в физической корневой файловой системе. 
Затем инструменты управления более высокого уровня должны поддерживать синхронизацию `/etc/passwd` или его эквивалента между операционными системами. 
Каждое развертывание можно легко перенастроить, чтобы установить собственный домашний каталог, просто сделав `/var/home` настоящим каталогом.

## Загрузка и технология initramfs

`OSTree` поставляется с дополнительным кодом интеграции `dracut + systemd`, который следует следующей логике:
- Анализ аргумента командной строки `ostree=kernel` в `initramfs`
- Монтирование (`bind mount`) каталога `/usr` в режиме только для чтения 
- Монтирование каталога `/sysroot` развертывания к физическому `/`
- Использование `mount` (`MS_MOVE`), для того, чтобы корень развертывания выглядел как корневая файловая система

После этих шагов `systemd` переключает `/.`

Если вы не используете `dracut` или `systemd`, использование `OSTree` по-прежнему возможно, **но вам придется написать код интеграции**. 
См. Существующие исходные коды в [src/switchroot](https://github.com/ostreedev/ostree/tree/master/src/switchroot) в качестве справки.

Патчи для поддержки других технологий `initramfs` и систем инициализации, если они будут достаточно чистыми, скорее всего, будут приняты апстримом.

Еще одно конкретное замечание относительно `sysvinit`: 
В `OSTree`  для поддержки файлов записывающих устройств, таких как `/dev/initctl` использовался `FIFO`, но в настоящий момент он больше не поддерживается. 
Рекомендуется просто пропатчить ваш `initramfs`, чтобы он создавался при загрузке. 

## /usr/lib/passwd

В отличие от традиционных систем пакетов, деревья `OSTree` содержат числовые идентификаторы `uid` и `gid`. 
Кроме того, у `OSTree` нет механизма типа `%post`, где можно было бы вызвать `useradd`. 
Чтобы установить ОС, которая содержит как системных пользователей, так и пользователей, динамически создаваемых на клиентских машинах, 
вам нужно будет подобрать решение для `/etc/passwd`. 
Основная проблема заключается в том, что если вы добавите пользователя в систему для демона, процесс обновления `OSTree` для `/etc` просто заметит, 
что, поскольку `/etc/passwd` отличается от предыдущего по умолчанию, он сохранит измененный файл конфигурации, 
а ваш новый Пользователь ОС не будет виден. 
Решение, выбранное для операционной системы [Gnome Continuous](https://wiki.gnome.org/action/show//GnomeOS?action=show&redirect=Projects%2FGnomeContinuous), - создать `/usr/lib/passwd` и включить модуль `NSS` [nss-altfiles](https://github.com/aperezdc/nss-altfiles), 
который инструктирует `glibc` читать из него. 
Затем система сборки помещает туда всех пользователей системы, освобождая `/etc/passwd` до чисто базы данных локальных пользователей. 
См. Также недавнюю работу [Systemd Stateless](http://0pointer.de/blog/projects/stateless.html). 

## Адаптация существующих менеджеров пакетов

Самым большой работой, вероятно, будет переработка диспетчера пакетов вашего дистрибутива, чтобы он работал поверх `OSTree`, особенно если вы хотите сохранить совместимость со «старым способом» установки в физический `/`. В этом разделе будут использоваться примеры как из `dpkg`, так и из `rpm`, поскольку автор знаком с обоими.
Но абстрактные концепции могут применяться и к большинству других традиционных менеджеров пакетов.

Есть много уровней возможной интеграции; 
Сначала мы опишем наиболее простую, но и наименее эффективную реализацию. 
Здесь мы предположим, что администратор загружен в систему с поддержкой `OSTree` и хочет добавить набор пакетов.

Многие менеджеры пакетов хранят свое состояние в `/var`; но поскольку в модели `OSTree` этот каталог является общим для независимых версий, 
база данных пакетов сначала должна быть перемещена в каталог `/usr` для каждого развертывания. 
Он становится доступным только для чтения. Помните, что все обновления включают построение нового дерева файловой системы, 
Поэтому вашему менеджеру пакетов также потребуется создать копию своей базы данных. 
Скорее всего, если вы хотите продолжить поддержку развертываний, отличных от `OSTree`, просто попросите ваш менеджер пакетов вернуться к устаревшему расположению `/var`, если тот, который находится в `/usr`, не найден.

Чтобы установить набор новых пакетов (без удаления каких-либо существующих), перечислите набор пакетов в текущем загруженном развертывании и 
выполните разрешение зависимостей для вычисления полного набора новых пакетов. 
Загрузите и распакуйте эти новые пакеты во временный каталог.

Теперь, поскольку мы просто устанавливаем новые пакеты и ничего не удаляем, 
мы можем провести основную оптимизацию, повторно используя существующее дерево файловой системы и 
просто разместив построенное дерево файловой системы этих новых пакетов поверх существующей. Вот такая команда:
```
ostree commit -b osname/$releasename/$description \
    --tree=ref=$osname/$releasename/$description \
    --tree=dir=/var/tmp/newpackages.13A8D0/
```
создаст новый коммит в ветке `$osname/$releasename/$description`. 
Контрольная сумма `OSTree` `SHA256` для всех файлов в `/var/tmp/newpackages.13A8D0/` будет вычислена, 
но мы не будем пересчитывать контрольную сумму существующего дерева. 
В этой многоуровневой модели более ранние каталоги будут иметь приоритет, но файлы на более поздних уровнях будут замещать более ранние уровни.

Затем, чтобы развернуть это дерево для следующей загрузки вызовем крманду: 
```
ostree admin deploy $osname/$releasename/$description
```
По сути, это то, что делает rpm-ostree для поддержки своей модели многоуровневых пакетов. 
