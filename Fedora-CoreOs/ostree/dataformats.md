# Форматы данных OSTree 

    On the topic of “smart servers”
    The archive format
    archive efficiency
    Aside: the bare and bare-user formats
    Static deltas
    Static delta repository layout
    Static delta internal structure
        The delta superblock
    A delta part
    Fallback objects
        Licensing for this document:

## По теме «умных серверов»

Одно действительно важное различие между OSTree и git состоит в том, что у git есть «умный сервер». Даже при загрузке по https: // это не просто статический веб-сервер, а тот, который, например, динамически вычисляет и сжимает файлы пакетов для каждого клиента.

Напротив, автор OSTree считает, что для обновлений операционной системы многие развертывания захотят использовать простые статические веб-серверы, те же цели, для которых было разработано большинство систем пакетов. Основными преимуществами являются безопасность и эффективность вычислений. Такие сервисы, как Amazon S3 и CDN, являются канонической целью, 
также как и источником - стандартный статический сервер nginx. 

## Формат archive

В разделе [Анатомия репозитория OSTree](anatomy.md)  была представлена ​​концепция объектов, в которых объекты file/content суммируются по контрольной сумме и управляются индивидуально. (В отличие от системы пакетов, которая работает со сжатыми агрегатами).

Формат archive просто сжимает каждый контентный объект с помощью gzip. 
Объекты метаданных хранятся без сжатия. 
Это означает, что данный формат легко поддерживать через статический HTTP сервер. 
> Примечание: в конфигурационном файле репо по-прежнему используется исторический термин archive-z2 в качестве режима. Но это, по сути, указывает на современный формат archive.

Когда вы делаете новый коммит на новый контент, вы увидите новые файлы `.filez` в  подкаталогах каталога `objects/`.

## Эффективность формата archive

Преимущества формата archive:

- Легко понять и реализовать
- Может обслуживаться статическим веб-сервером напрямую по обычному протоколу HTTP.
- Клиенты могут скачивать/распаковывать обновления постепенно
- Эффективное использование пространства на сервере

Самым большим недостатком этого формата является то, что для выполнения обновления клиентом требуется один HTTP-запрос на каждый измененный файл. 
В некоторых сценариях это на самом деле совсем неплохо, особенно с методами уменьшения накладных расходов HTTP, такими как HTTP / 2.

Чтобы этот формат работал хорошо, вы должны разрабатывать свой контент таким образом, чтобы большие данные, 
которые нечасто изменяются (например, графические изображения), хранились отдельно от небольших, 
часто меняющихся данных (кода приложения).

Другие недостатки формата archive:

- Это очень плохо, когда клиенты выполняют начальное опрашивание (без HTTP / 2),
- Никто не знает общий размер (сжатый или несжатый) контента перед загрузкой всего объема


## bare и bare-user форматы

Самая распространенная в OSTree операция - `pull` из репозитория формата `archive` в репозитории формата `bare` и `user bare`. 
Последние два формата хранят данные на диске в исходном несжатом виде.
Другими словами, операция 'pull'  аналогична операции разжатия ((но не установке)) файлов rpm/deb-пакетов

Формат `bare-user`  немного особенный, поскольку в нем игнорируются идентификаторы uid / gid и xattrs из содержимого. 
Это в первую очередь полезно, если вы хотите иметь тот же контент, управляемый OSTree, который можно запускать в хост-системе или непривилегированном контейнере. 

## Статические дельты

OSTree изначально был ориентирован на `continuous delivery` модель, при которой клиентские системы должны регулярно обновляться. 
Однако многие поставщики ОС хотели бы предоставлять обновленный контент, например раз в месяц или реже.

Для этой модели мы можем намного лучше поддерживать пакетные обновления, чем базовое архивное репо. Однако мы по-прежнему хотим сохранить модель «только статический веб-сервер». 
Учитывая это, в рамках OSTree разработана концепция «статической дельты».

Эти дельты нацелены на то, чтобы быть разницей между двумя конкретными коммитами, включая дельты «bsdiff» и «rsync-style» в объекте содержимого. 
Статические дельты также поддерживаются от NULL, когда клиент может более эффективно загружать объект фиксации с нуля - это в основном полезно при использовании OSTree для контейнеров, а не образов ОС. 
Для образов ОС обычно загружают установочный ISO-образ или образ qcow2, который представляет собой отдельный файл, который уже содержит данные дерева.

По сути, мы тратим ресурсы  на стороне сервера (и единовременные затраты на вычисления) и повышаем эффективность использования полосы пропускания клиентской сети. 

## Статический макет дельта-репозитория

Поскольку статические дельты могут не существовать, клиенту сначала нужно попытаться найти их. 
Предположим, клиент хочет получить фиксацию ${new} во время выполнения ${current}.

В целях экономии места эти два коммита представляют собой «измененный base64» - символ `/` заменяется на `_`.

Как и коммиты, «каталог префиксов» используется для упрощения управления инструментами файловой системы.

Дельта подучает имя $ (mbase64 $from)-$(mbase64 $to), например, GpTyZaVut2jXFPWnO4LJiKEdRTvOw_mFUCtIKW1NIX0-L8f+VVDkEBKNc1Ncd+mDUrSVR4EyybQGCkuKtkDnTwk, которая в формате SHA256 представляется как 1a94f265a56eb768d714f5a73b82c988a11d453bcec3f985502b48296d4d217d-2fc7fe5550e410128d73535c77e98352b495478132c9b4060a4b8ab640e74f09.

Наконец, фактическое содержимое можно найти в deltas `deltas/$fromprefix/$fromsuffix-$to`. 

## Статическая дельта - внутренняя структура

Дельта сама по себе является каталогом. Внутри находится файл под названием `superblock`, содержащий метаданные. 
Остальные файлы будут целыми числами, содержащими пакеты содержимого.

Формат файла статических дельт в настоящее время следует рассматривать как деталь реализации OSTree. 
Очевидно, ничто не мешает писать код, совместимый с OSTree сегодня. Однако нам нужна гибкость, позволяющая расширять и изменять вещи, а наличие нескольких баз кода делает это более проблематичным. Пожалуйста, свяжитесь с авторами по любыми вопросам.

Тем не менее, одна важная вещь, которую необходимо понять при проектировании, заключается в том, что дельта-данные немного больше похожи на «ограниченные программы», чем на необработанные данные. Есть фаза «компиляции», на которой генерируются выходные данные, которые выполняет клиент.

Эта модель «обновления как код» позволяет использовать несколько стратегий создания контента. Его дизайн был вдохновлен дизайном Chromium: ChromiumOS Autoupdate.

### Дельта суперблок

Суперблок содержит:

- произвольные метаданные
- отметка времени генерации дельты
- новый коммит
- Массив рекурсивных дельт для применения
- Массив метаданных по частям, включая общие размеры объектов (сжатые и несжатые),
- Массив резервных (fallback) объектов

Давайте определим дельта-часть, а затем вернемся к обсуждению деталей: 

### Дельта-часть

Дельта-часть - это комбинация необработанного большого двоичного объекта данных и очень ограниченного байт-кода, который работает с ним. Скажем, например, два файла имеют общий раздел. Дельта-компиляция может включить этот раздел один раз в большой двоичный объект дельта-данных, а затем сгенерировать инструкции для записи этого большого двоичного объекта дважды при создании обоих объектов.

На самом деле, очень часто дельта представляет собой просто «поток новых объектов» - если учесть это, не имеет смысла иметь слишком много дублирования внутри содержимого операционной системы на этом уровне.

Итак, что более интересно, так это то, что статические дельты OSTree поддерживают алгоритм дельты для каждого файла, называемый bsdiff, который особенно хорошо работает с исполняемым кодом.

Текущий дельта-компилятор сканирует файлы с совпадающими базовыми именами в каждой фиксации, которые имеют аналогичный размер, и пытается выполнить bsdiff между ними. (Позже будет иметь смысл, чтобы система сборки предоставляла подсказку для этого - например, файлы в одном пакете).

Сгенерированный bsdiff включается в большой двоичный объект и обрабатывается определенным программным кодом при разворачивании. 

## Fallback объекты

Файловая система может включать файлы большого размера, "устойчивые" к bsdiff-оптимизации. 
Хорошим примером является то, что операционные системы часто используют initramfs, который сам по себе является сжатой файловой системой. 
Это «внутреннее сжатие» делает bsdiff неэффективным.

Для этих типов объектов дельта-суперблок содержит массив Fallback-объектов». 
Эти объекты не входят в состав дельта-частей - клиент просто извлекает их из нижележащего объекта `.filez`. 

